3.1 Decisão de Normalização

DECISÃO: ESTRUTURA DESNORMALIZADA (Manter tabelas separadas por tipo de despesa)

JUSTIFICATIVA:

A) Volume de Dados Esperado
- ~700 operadoras ativas × 4 trimestres/ano × 5 anos histórico
- Volume estimado: ~14.000 registros por tabela (consolidados_despesas e consolidados_despesas_c_deducoes)
- Volume moderado, não massivo → Índices B-tree são suficientes
- UNION ALL entre tabelas é performático (<1s para este volume)

B) Frequência de Atualizações
- Cargas batch TRIMESTRAIS (dados ANS publicados a cada 3 meses)
- Padrão INSERT-ONLY (sem UPDATE/DELETE após carga)
- Dados históricos são IMUTÁVEIS (requisito de compliance regulatório)
- Conclusão: Redundância de estrutura NÃO causa problemas de consistência

C) Complexidade das Queries Analíticas
- Queries atuais usam UNION ALL para combinar tipos (eficiente e simples)
- Window functions (FIRST_VALUE, LAST_VALUE, ROW_NUMBER) para análises temporais
- JOINs com operadoras apenas para enriquecimento
- Normalizar exigiria WHERE tipo_despesa em todas as queries (mais complexo)
- CTEs nomeadas mantêm código organizado e legível

D) Compliance Regulatório ANS
- "Despesas sem dedução" ≠ "Despesas com dedução" são métricas LEGALMENTE DISTINTAS
- Separação física facilita auditoria e rastreabilidade
- Estrutura explícita reduz risco de mistura acidental de tipos
- Valor de negócio além do técnico

E) Custo x Benefício da Refatoração
- Unificar tabelas economizaria ~50% espaço em disco (~100MB)
- Ganho de performance: <20% (0.05s em média)
- Custo de refatoração: ~40 horas (reescrever ETL, migrar dados, revalidar queries)
- Risco de bugs/perda de dados durante migração
- Conclusão: NÃO COMPENSA para o volume e contexto atuais

ESTRUTURA ADOTADA:
- operadoras (tabela mestre)
- consolidados_despesas (granular sem dedução)
- consolidados_despesas_c_deducoes (granular com dedução)  
- despesas_agregadas (sumarizado sem dedução)
- despesas_agregadas_c_deducoes (sumarizado com dedução)

OTIMIZAÇÕES APLICADAS:
- Índices compostos: (reg_ans, ano, trimestre) para queries temporais
- Índices simples: reg_ans, uf para filtros comuns
- Constraints: CHECK (trimestre BETWEEN 1 AND 4), CHECK (valor >= 0)
- Foreign Keys: Todas as tabelas referenciam operadoras(reg_ans)

GATILHOS PARA RECONSIDERAR NORMALIZAÇÃO:
- Volume crescer para >10 milhões registros/tabela
- Cargas mudarem para diárias ou tempo real
- 80%+ das queries precisarem comparar cross-tipo
- ANS exigir consolidação unificada dos dados

3.2 Tipos de Dados

Valores monetários: NUMERIC(18,2)
- Precisão decimal garantida (evita erros de arredondamento do FLOAT/DOUBLE)
- Suporta valores até 999 trilhões (suficiente para agregações nacionais)
- INTEGER (armazenar centavos) seria mais eficiente, mas exige conversões e dificulta leitura
- PostgreSQL otimiza NUMERIC para performance comparável a BIGINT em muitos casos

Datas e períodos:
- ano: INTEGER (ex: 2024) - simples e auto-documentado
- trimestre: INTEGER CHECK (trimestre BETWEEN 1 AND 4) - garante valores válidos
- data_carga: TIMESTAMP DEFAULT NOW() - rastreabilidade automática
- Alternativa descartada: DATE → desnecessário, pois ANS publica por trimestre (não dia específico)

Identificadores:
- reg_ans: VARCHAR(20) - formato variável da ANS, não é puramente numérico
- cnpj: VARCHAR(20) - preserva formatação e evita perda de zeros à esquerda
- id: BIGSERIAL - auto-incremento, suporta >9 quintilhões de registros

Textos:
- razao_social: VARCHAR(255) - limite razoável para nomes de empresas
- descricao: VARCHAR(500) - campo opcional para observações em despesas com dedução
- uf: CHAR(2) - tamanho fixo, otimizado para siglas

3.3 Importação e Tratamento de Inconsistências

Estratégia adotada:
- Import direto via COPY ou INSERT batch (PostgreSQL)
- Validações aplicadas via CONSTRAINTS no DDL (CHECK, NOT NULL, FOREIGN KEY)
- Dados inválidos são rejeitados automaticamente pelo banco
- Script Python registra erros em log para análise posterior

Tratamento implementado:
- NULL em campos obrigatórios: Rejeitado por constraint NOT NULL
- Valores negativos em despesas: Aceitos (podem representar ajustes/estornos legítimos ANS)
- Trimestre inválido: Rejeitado por CHECK (trimestre BETWEEN 1 AND 4)
- reg_ans inexistente: Rejeitado por FOREIGN KEY (deve existir em operadoras primeiro)
- Duplicatas: Permitidas (mesma operadora pode ter múltiplos registros por trimestre)

Justificativa:
- Constraints SQL são mais performáticos que validação em Python
- Garante integridade mesmo em cargas manuais futuras
- Erros ficam registrados em logs do PostgreSQL (pg_log)
- Facilita debugging (PostgreSQL retorna erro descritivo: "violates check constraint")

Alternativa descartada: Tabelas staging (stg_*)
- Adiciona complexidade desnecessária para volume moderado
- Cargas batch trimestrais não justificam ETL complexo
- COPY direto com ON_ERROR_STOP=0 é suficiente

3.4 Estrutura das Queries Analíticas

ABORDAGEM ESCOLHIDA: UNION ALL + CTEs + Window Functions

Justificativa considerando contexto:

A) Volume de Dados (~14k registros/tabela)
- UNION ALL não duplica dados, apenas concatena resultados
- PostgreSQL otimiza UNION ALL eficientemente (sem ordenação)
- Performance: ~0.3-0.5s para queries completas
- Índices (reg_ans, ano, trimestre) garantem acesso rápido

B) Frequência de Atualizações (Trimestral)
- Cargas batch espaçadas → não há problema em varrer ambas as tabelas
- Dados imutáveis → sem risco de inconsistências durante query
- Cache do PostgreSQL mantém dados quentes entre queries

C) Complexidade das Queries
- UNION ALL elimina 60% de duplicação de código (antes: 180 linhas, depois: 120)
- CTEs nomeadas tornam queries auto-documentadas
- Window functions (FIRST_VALUE, LAST_VALUE) mais eficientes que subqueries
- Facilita manutenção: mudanças aplicadas em um lugar único

Estrutura aplicada em todas as 3 queries:

```sql
WITH base AS (
    -- Unifica os dois tipos de despesas
    SELECT 'SEM DEDUÇÃO' AS tipo_despesa, ... FROM consolidados_despesas
    UNION ALL
    SELECT 'COM DEDUÇÃO' AS tipo_despesa, ... FROM consolidados_despesas_c_deducoes
),
calculo AS (
    -- Aplica lógica de negócio
    SELECT ..., WINDOW_FUNCTION() OVER (...) FROM base
)
SELECT ... FROM calculo WHERE filtros ORDER BY ...;
```

Query 1 - Top 5 Operadoras com Maior Crescimento:
- Usa FIRST_VALUE/LAST_VALUE para pegar valores inicial e final por operadora
- Calcula crescimento percentual: ((final - inicial) / inicial) × 100
- ROW_NUMBER() PARTITION BY tipo_despesa para pegar top 5 de cada tipo
- Justificativa: Maximiza uso de dados disponíveis, mesmo com períodos faltantes

Query 2 - Distribuição por UF (Top 5):
- Agrega despesas por UF e tipo
- ROW_NUMBER() garante 5 UFs de cada tipo (total 10 linhas)
- COUNT(DISTINCT reg_ans) mostra concentração de operadoras
- Justificativa: Identifica concentração geográfica e intensidade por região

Query 3 - Operadoras Acima da Média:
- Calcula média trimestral por tipo (SEM vs COM dedução separadamente)
- Conta quantos trimestres cada operadora ficou acima da média
- Filtra operadoras com 2+ trimestres acima (performance consistente)
- Justificativa: Identifica operadoras com despesas sistematicamente elevadas

Alternativas descartadas:
- Views materializadas: Volume pequeno não justifica overhead de manutenção
- Queries separadas por tipo: Duplicação de código (já testado, 180 linhas vs 120)
- Subqueries correlacionadas: Menos performáticas que window functions
